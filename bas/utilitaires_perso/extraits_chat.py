"/**\n * Définition des patterns d'opération valides pour chaque type\n * avec vérification intrinsèque de la compatibilité des types\n */\nconst OPERATION_PATTERNS = {\n    'int': [\n        {\n            pattern: '{var} = {var} + {int}',\n            description: 'Addition',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${varName} = ${varName} + ${value}`;\n            }\n        },\n        {\n            pattern: '{var} = {int} + {var}',\n            description: 'Addition inversée',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${value} + ${varName}`;\n            }\n        },\n        {\n            pattern: '{var} += {int}',\n            description: 'Addition avec opérateur composé',\n            minDifficulty: 2,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${varName} += ${value}`;\n            }\n        },\n        {\n            pattern: '{var} = {var} * {int}',\n            description: 'Multiplication',\n            minDifficulty: 2,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(2, difficulty+1);\n                return `${varName} = ${varName} * ${value}`;\n            }\n        },\n        // Plus de patterns pour int...\n    ],\n    'str': [\n        {\n            pattern: '{var} = {var} + {str}',\n            description: 'Concaténation',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const text = getRandomItem([\"texte\", \"donnée\", \"valeur\", \"info\"]);\n                return `${varName} = ${varName} + \" ${text}\"`;\n            }\n        },\n        {\n            pattern: '{var} += {str}',\n            description: 'Concaténation avec +=',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const text = getRandomItem([\"texte\", \"donnée\", \"valeur\", \"info\"]);\n                return `${varName} += \" ${text}\"`;\n            }\n        },\n        {\n            pattern: '{var} = {var}.upper()',\n            description: 'Conversion en majuscules',\n            minDifficulty: 3,\n            generate: (varName) => `${varName} = ${varName}.upper()`\n        },\n        // Plus de patterns pour str...\n    ],\n    'list': [\n        {\n            pattern: '{var}.append({int})',\n            description: 'Ajout d\\'élément',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+3);\n                return `${varName}.append(${value})`;\n            }\n        },\n        // Plus de patterns pour list...\n    ],\n    // Autres types...\n};\n\n/**\n * Patterns pour les opérations entre types mixtes\n * Ces patterns sont particulièrement importants pour éviter les erreurs de type\n */\nconst MIXED_TYPE_PATTERNS = [\n    {\n        types: ['str', 'int'],\n        pattern: '{str} = {str} + str({int})',\n        description: 'Concaténation string+int avec conversion',\n        minDifficulty: 2,\n        generate: (strVar, intVar) => {\n            return `${strVar} = ${strVar} + str(${intVar})`;\n        }\n    },\n    {\n        types: ['str', 'list'],\n        pattern: '{str} = {str} + str({list})',\n        description: 'Concaténation string+liste avec conversion',\n        minDifficulty: 3,\n        generate: (strVar, listVar) => {\n            return `${strVar} = ${strVar} + str(${listVar})`;\n        }\n    },\n    // Autres patterns mixtes...\n];\n\n/**\n * Patterns spécifiques pour les corps de structures\n */\nconst STRUCTURE_BODY_PATTERNS = {\n    'for_list': [\n        {\n            pattern: '{var_int} = {var_int} + {loop_var}',\n            description: 'Additionner l\\'élément à une variable entière',\n            minDifficulty: 1,\n            applicableTypes: ['int', 'int'],\n            generate: (targetVar, loopVar) => `${targetVar} = ${targetVar} + ${loopVar}`\n        },\n        {\n            pattern: '{var_str} = {var_str} + str({loop_var})',\n            description: 'Concaténer l\\'élément à une chaîne avec conversion',\n            minDifficulty: 1,\n            applicableTypes: ['str', 'any'],\n            generate: (targetVar, loopVar) => `${targetVar} = ${targetVar} + str(${loopVar})`\n        },\n        {\n            pattern: 'if {loop_var} > 0:',\n            description: 'Condition sur l\\'élément de liste',\n            minDifficulty: 2,\n            applicableTypes: ['any', 'numeric'],\n            generate: (targetVar, loopVar) => \n                `if ${loopVar} > 0:\\n    ${targetVar} += 1`\n        },\n        // Plus de patterns...\n    ],\n    'for_str': [\n        // Patterns pour for_str...\n    ],\n    'while': [\n        // Patterns pour while...\n    ],\n    // Autres types de structures...\n};\n````\n\n## 2. Fonction principale pour générer des opérations variées\n\n````javascript\n"
"function generateMixedTypeOperation(difficulty) {\n    // Filtrer les patterns selon la difficulté\n    const availablePatterns = MIXED_TYPE_PATTERNS\n        .filter(p => p.minDifficulty <= difficulty);\n    \n    if (availablePatterns.length === 0) return null;\n    \n    // Sélectionner un pattern aléatoire\n    const selectedPattern = getRandomItem(availablePatterns);\n    \n    // Vérifier si nous avons les variables nécessaires\n    const requiredTypes = selectedPattern.types;\n    const selectedVars = [];\n    \n    for (const type of requiredTypes) {\n        if (declaredVarsByType[type] && declaredVarsByType[type].length > 0) {\n            selectedVars.push(getRandomItem(declaredVarsByType[type]));\n        } else {\n            return null; // Pas assez de variables des types requis\n        }\n    }\n    \n    // Générer l'opération mixte\n    return selectedPattern.generate(...selectedVars);\n}\n````\n\n## 4. Fonction améliorée pour les corps de structures\n\n````javascript\n"
"function generateMixedTypeOperation(difficulty) {\n    // Filtrer les patterns selon la difficulté\n    const availablePatterns = MIXED_TYPE_PATTERNS\n        .filter(p => p.minDifficulty <= difficulty);\n    \n    if (availablePatterns.length === 0) return null;\n    \n    // Sélectionner un pattern aléatoire\n    const selectedPattern = getRandomItem(availablePatterns);\n    \n    // Vérifier si nous avons les variables nécessaires\n    const requiredTypes = selectedPattern.types;\n    const selectedVars = [];\n    \n    for (const type of requiredTypes) {\n        if (declaredVarsByType[type] && declaredVarsByType[type].length > 0) {\n            selectedVars.push(getRandomItem(declaredVarsByType[type]));\n        } else {\n            return null; // Pas assez de variables des types requis\n        }\n    }\n    \n    // Générer l'opération mixte\n    return selectedPattern.generate(...selectedVars);\n}\n",
"/**\n * Table de compatibilité des opérations entre types Python\n */\nconst TYPE_COMPATIBILITY = {\n    'str': {\n        '+': ['str'],                 // str + str -> str\n        '+=': ['str'],                // str += str -> str\n        '*': ['int'],                 // str * int -> str\n        '*=': ['int'],                // str *= int -> str\n        'in': ['str'],                // char in str -> bool\n        'not in': ['str'],            // char not in str -> bool\n        '[]': ['int'],                // str[int] -> str\n        '[:]': ['int', 'int'],        // str[int:int] -> str\n    },\n    'int': {\n        '+': ['int', 'float'],        // int + (int|float) -> (int|float)\n        '-': ['int', 'float'],        // int - (int|float) -> (int|float)\n        '*': ['int', 'float', 'str'], // int * (int|float|str) -> (int|float|str)\n        '/': ['int', 'float'],        // int / (int|float) -> float\n        '//': ['int', 'float'],       // int // (int|float) -> int\n        '%': ['int', 'float'],        // int % (int|float) -> int\n        '**': ['int', 'float'],       // int ** (int|float) -> (int|float)\n        // Plus d'opérations...\n    },\n    // Autres types...\n};\n\n/**\n * Vérifie si une opération est valide entre deux types Python.\n * @param {string} leftType - Type de la variable de gauche\n * @param {string} operator - Opérateur\n * @param {string} rightType - Type de la variable/valeur de droite\n * @returns {boolean} - True si l'opération est valide\n */\nfunction isOperationValid(leftType, operator, rightType) {\n    if (!TYPE_COMPATIBILITY[leftType]) return false;\n    if (!TYPE_COMPATIBILITY[leftType][operator]) return false;\n    \n    return TYPE_COMPATIBILITY[leftType][operator].includes(rightType);\n}\n````\n\n## 6. Comment intégrer cette solution dans votre architecture\n\n1. **Créez un module pour les patterns**: Stockez les définitions OPERATION_PATTERNS, MIXED_TYPE_PATTERNS, etc. dans un fichier séparé que vous importerez.\n\n2. **Modifiez generateVariedOperation**: Remplacez la logique actuelle par celle basée sur les patterns.\n\n3. **Améliorez generateStructureBody**: Utilisez les patterns définis pour générer des corps de structure plus robustes.\n\n4. **Ajoutez la vérification de types**: Utilisez isOperationValid comme garde-fou avant de générer une opération.\n\n## Avantages de cette approche\n\n1. **Robustesse intrinsèque**: Chaque pattern est défini pour être valide en Python, éliminant les erreurs de type.\n  \n2. **Maintenabilité améliorée**: Les patterns sont clairement définis et documentés, facilitant les ajouts ou modifications.\n\n3. **Extensibilité**: Ajoutez facilement de nouveaux patterns sans toucher à la logique du générateur.\n\n4. **Contrôle précis de la difficulté**: Chaque pattern a un niveau de difficulté minimal, permettant une progression pédagogique claire.\n\n5. **Variété garantie**: Vous pouvez définir autant de patterns que nécessaire pour enrichir l'expérience d'apprentissage.\n\nCette approche transformerait votre générateur en un système plus robuste et plus facile à maintenir, tout en offrant une plus grande variété de structures générées.",
"/**\n * Définition des patterns d'opération valides pour chaque type\n * avec vérification intrinsèque de la compatibilité des types\n */\nconst OPERATION_PATTERNS = {\n    'int': [\n        {\n            pattern: '{var} = {var} + {int}',\n            description: 'Addition',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${varName} = ${varName} + ${value}`;\n            }\n        },\n        {\n            pattern: '{var} = {int} + {var}',\n            description: 'Addition inversée',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${value} + ${varName}`;\n            }\n        },\n        {\n            pattern: '{var} += {int}',\n            description: 'Addition avec opérateur composé',\n            minDifficulty: 2,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+1);\n                return `${varName} += ${value}`;\n            }\n        },\n        {\n            pattern: '{var} = {var} * {int}',\n            description: 'Multiplication',\n            minDifficulty: 2,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(2, difficulty+1);\n                return `${varName} = ${varName} * ${value}`;\n            }\n        },\n        // Plus de patterns pour int...\n    ],\n    'str': [\n        {\n            pattern: '{var} = {var} + {str}',\n            description: 'Concaténation',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const text = getRandomItem([\"texte\", \"donnée\", \"valeur\", \"info\"]);\n                return `${varName} = ${varName} + \" ${text}\"`;\n            }\n        },\n        {\n            pattern: '{var} += {str}',\n            description: 'Concaténation avec +=',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const text = getRandomItem([\"texte\", \"donnée\", \"valeur\", \"info\"]);\n                return `${varName} += \" ${text}\"`;\n            }\n        },\n        {\n            pattern: '{var} = {var}.upper()',\n            description: 'Conversion en majuscules',\n            minDifficulty: 3,\n            generate: (varName) => `${varName} = ${varName}.upper()`\n        },\n        // Plus de patterns pour str...\n    ],\n    'list': [\n        {\n            pattern: '{var}.append({int})',\n            description: 'Ajout d\\'élément',\n            minDifficulty: 1,\n            generate: (varName, difficulty) => {\n                const value = getRandomInt(1, difficulty+3);\n                return `${varName}.append(${value})`;\n            }\n        },\n        // Plus de patterns pour list...\n    ],\n    // Autres types...\n};\n\n/**\n * Patterns pour les opérations entre types mixtes\n * Ces patterns sont particulièrement importants pour éviter les erreurs de type\n */\nconst MIXED_TYPE_PATTERNS = [\n    {\n        types: ['str', 'int'],\n        pattern: '{str} = {str} + str({int})',\n        description: 'Concaténation string+int avec conversion',\n        minDifficulty: 2,\n        generate: (strVar, intVar) => {\n            return `${strVar} = ${strVar} + str(${intVar})`;\n        }\n    },\n    {\n        types: ['str', 'list'],\n        pattern: '{str} = {str} + str({list})',\n        description: 'Concaténation string+liste avec conversion',\n        minDifficulty: 3,\n        generate: (strVar, listVar) => {\n            return `${strVar} = ${strVar} + str(${listVar})`;\n        }\n    },\n    // Autres patterns mixtes...\n];\n\n/**\n * Patterns spécifiques pour les corps de structures\n */\nconst STRUCTURE_BODY_PATTERNS = {\n    'for_list': [\n        {\n            pattern: '{var_int} = {var_int} + {loop_var}',\n            description: 'Additionner l\\'élément à une variable entière',\n            minDifficulty: 1,\n            applicableTypes: ['int', 'int'],\n            generate: (targetVar, loopVar) => `${targetVar} = ${targetVar} + ${loopVar}`\n        },\n        {\n            pattern: '{var_str} = {var_str} + str({loop_var})',\n            description: 'Concaténer l\\'élément à une chaîne avec conversion',\n            minDifficulty: 1,\n            applicableTypes: ['str', 'any'],\n            generate: (targetVar, loopVar) => `${targetVar} = ${targetVar} + str(${loopVar})`\n        },\n        {\n            pattern: 'if {loop_var} > 0:',\n            description: 'Condition sur l\\'élément de liste',\n            minDifficulty: 2,\n            applicableTypes: ['any', 'numeric'],\n            generate: (targetVar, loopVar) => \n                `if ${loopVar} > 0:\\n    ${targetVar} += 1`\n        },\n        // Plus de patterns...\n    ],\n    'for_str': [\n        // Patterns pour for_str...\n    ],\n    'while': [\n        // Patterns pour while...\n    ],\n    // Autres types de structures...\n};\n"
